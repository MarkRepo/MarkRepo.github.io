---
title: intel 处理器手册翻译
description: copy 谷歌翻译~
categories: algorithm
tags:
---

2.1 英特尔® 64 位和 IA-32 架构简史

以下部分提供了从 IA-32 到 Intel 64 架构的主要技术演变的摘要：从 Intel 8086 处理器到最新的 Intel® Core® 2 Duo、Core 2 Quad 和 Intel Xeon 处理器 5300 和 7300 系列。 为早在 1978 年发布的处理器创建的目标代码仍在 Intel 64 和 IA-32 架构系列中的最新处理器上执行

2.1.1 16 位处理器和分段

IA-32 体系结构系列之前是 16 位处理器 8086 和 8088。8086 有 16 位寄存器和 16 位外部数据总线，20 位寻址提供 1 兆字节的地址空间。 8088 与 8086 类似，只是它有一个 8 位外部数据总线。
8086/8088 在 IA-32 架构中引入了分段。 通过分段，一个 16 位的段寄存器包含一个指向最大 64 KB 内存段的指针。 一次使用四个段寄存器，8086/8088 处理器能够寻址多达 256 KB 而无需在段之间切换。 可以使用段寄存器和附加的 16 位指针形成的 20 位地址提供了 1 MByte 的总地址范围。

2.1.2 英特尔® 286 处理器 (1982)
Intel 286 处理器在 IA-32 架构中引入了保护模式操作。 保护模式使用段寄存器内容作为描述符表的选择器或指针。 描述符提供 24 位基地址，物理内存大小高达 16 MBytes，支持基于段交换的虚拟内存管理，以及许多保护机制。 这些机制包括：
• 段限制检查
• 只读和只执行段选项
• 四个权限级别

2.1.3 Intel386™ 处理器 (1985)

Intel386 处理器是 IA-32 架构系列中的第一个 32 位处理器。 它引入了 32 位寄存器，用于保存操作数和寻址。 每个 32 位 Intel386 寄存器的下半部分保留了前几代 16 位寄存器的属性，允许向后兼容。 该处理器还提供了一种虚拟 8086 模式，在执行为 8086/8088 处理器创建的程序时可以提高效率。
此外，Intel386 处理器还支持：
• 支持高达 4 GB 物理内存的 32 位地址总线
• 分段内存模型和平面内存模型
• 分页，具有固定的 4 KB 页大小，提供了一种虚拟内存管理方法
• 支持并行阶段

2.1.4 Intel486™ 处理器 (1989)

Intel486™ 处理器通过将 Intel386 处理器的指令解码和执行单元扩展为五个流水线级，增加了更多的并行执行能力。 在不同的执行阶段，每个阶段最多可在 5 条指令上与其他阶段并行运行。

此外，处理器还添加了：
• 一个 8 KB 的片上一级缓存，增加了可以以每个时钟一个标量速率执行的指令的百分比
• 一个集成的 x87 FPU
• 节能和系统管理能力

2.1.5 英特尔® 奔腾® 处理器 (1993)

Intel Pentium 处理器的引入增加了第二个执行流水线以实现超标量性能（两条流水线，称为 u 和 v，每个时钟一起可以执行两条指令）。 片上一级缓存加倍，其中 8 KB 用于代码，另外 8 KB 用于数据。 数据缓存使用 MESI 协议，除了 Intel486 处理器以前使用的直写缓存之外，还支持更高效的回写缓存。 添加了带有片上分支表的分支预测以提高循环结构的性能。
此外，处理器还添加了：
• 使虚拟 8086 模式更高效并允许 4 兆字节和 4 兆字节页面的扩展
• 128 和 256 位的内部数据路径增加了内部数据传输的速度
• 突发外部数据总线增加到 64 位
• 支持多处理器系统的 APIC
• 支持无缝双处理器系统的双处理器模式
奔腾家族的后续步进引入了英特尔 MMX 技术（具有 MMX 技术的奔腾处理器）。 英特尔 MMX 技术使用单指令、多数据 (SIMD) 执行模型对 64 位寄存器中包含的打包整数数据执行并行计算。
请参见第 2.2.7 节“SIMD 指令”。

2.1.6 P6 系列处理器（1995-1999）

P6 系列处理器基于设定新性能标准的超标量微体系结构； 另请参见第 2.2.1 节“P6 系列微体系结构”。 P6 系列微架构设计的目标之一是在使用相同的 0.6 微米四层金属 BICMOS 制造工艺的同时显着超越奔腾处理器的性能。 这个家族的成员包括：
• Intel Pentium Pro 处理器是三路超标量处理器。 使用并行处理技术，处理器平均每个时钟周期能够解码、分派和完成（退出）三个指令的执行。 Pentium Pro 在超标量实现中引入了动态执行（微数据流分析、乱序执行、高级分支预测和推测执行）。 该处理器通过其高速缓存得到了进一步增强。 它具有与奔腾处理器相同的两个片上 8 KB 一级缓存，并在与处理器相同的封装中具有额外的 256 KB 二级缓存。
• Intel Pentium II 处理器将 Intel MMX 技术添加到 P6 系列处理器中，同时采用了新的封装和多项硬件增强功能。 处理器内核封装在单边接触盒 (SECC) 中。 Level l 数据和指令缓存分别扩大到 16 KB，支持 256 KByte、512 KByte 和 1 MByte 的 Level 2 缓存大小。 半频后端总线将二级缓存连接到处理器。 支持多种低功耗状态，例如 AutoHALT、Stop-Grant、Sleep 和 Deep Sleep，以在空闲时节省电量。
• Pentium II Xeon 处理器结合了前几代英特尔处理器的卓越特性。 这包括：4 路、8 路（及以上）可扩展性和运行在全频后端总线上的 2 MByte 二级缓存。
• 英特尔赛扬处理器系列专注于价值型个人电脑市场。 它的推出提供了集成的 128 KBytes 二级缓存和塑料引脚网格阵列 (P.P.G.A.) 外形规格，以降低系统设计成本。
• Intel Pentium III 处理器将Streaming SIMD Extensions (SSE) 引入到IA-32 架构中。
SSE 扩展通过提供一组新的 128 位寄存器和对压缩单精度浮点值执行 SIMD 操作的能力扩展了英特尔 MMX 技术引入的 SIMD 执行模型。 请参见第 2.2.7 节“SIMD 指令”。
• Pentium III Xeon 处理器扩展了 IA-32 处理器的性能水平，增强了全速、片上和高级传输高速缓存。

2.1.7 英特尔® 奔腾® 4 处理器家族 (2000-2006)

Intel Pentium 4 处理器系列基于 Intel NetBurst 微架构； 请参阅第 2.2.2 节“英特尔 NetBurst® 微体系结构”。
Intel Pentium 4 处理器引入了 Streaming SIMD Extensions 2 (SSE2)； 请参阅第 2.2.7 节“SIMD 指令”。 Intel Pentium 4 处理器 3.40 GHz，支持超线程技术引入了 Streaming SIMD Extensions 3 (SSE3)； 请参阅第 2.2.7 节“SIMD 指令”。
英特尔 64 位架构在支持超线程技术的英特尔奔腾 4 处理器至尊版以及英特尔奔腾 4 处理器 6xx 和 5xx 序列中引入。
英特尔® 虚拟化技术（英特尔® VT）被引入英特尔奔腾 4 处理器 672 和 662。

2.1.8 英特尔® 至强® 处理器（2001-2007）

英特尔至强处理器（双核英特尔至强处理器 LV、英特尔至强处理器 5100 系列除外）基于英特尔 NetBurst 微架构； 请参阅第 2.2.2 节“英特尔 NetBurst® 微体系结构”。 作为一个系列，这组 IA-32 处理器（最近的 Intel 64 处理器）设计用于多处理器服务器系统和高性能工作站。
英特尔至强处理器 MP 引入了对英特尔® 超线程技术的支持； 请参阅第 2.2.8 节，“英特尔® 超线程技术”。
64 位 Intel Xeon 处理器 3.60 GHz（具有 800 MHz 系统总线）用于引入 Intel 64 架构。 双核 Intel Xeon 处理器包括双核技术。 英特尔至强处理器 70xx 系列包括英特尔虚拟化技术。
英特尔至强处理器 5100 系列引入了节能、高性能的英特尔酷睿微架构。
该处理器基于Intel 64架构； 它包括英特尔虚拟化技术和双核技术。 英特尔至强处理器 3000 系列也基于英特尔酷睿微架构。 英特尔至强
处理器 5300 系列在一个物理封装中引入了四个处理器内核，它们同样基于英特尔酷睿微架构。

2.1.9 英特尔® 奔腾® M 处理器 (2003-2006)

Intel Pentium M 处理器系列是一个高性能、低功耗的移动处理器系列，与前几代 IA-32 Intel 移动处理器相比具有微架构增强功能。 该系列旨在延长电池寿命并与支持新使用模型（例如扩展移动性、超薄外形和集成无线网络）的平台创新无缝集成。
其增强的微架构包括：
• 支持动态执行的英特尔架构
• 高性能、低功耗内核，采用英特尔先进的铜互连工艺技术制造
• 片上 32 KB 主指令缓存和 32 KB 回写数据缓存
• 具有高级传输缓存架构的片上二级缓存（高达 2 MByte）
• 高级分支预测和数据预取逻辑
• 支持 MMX 技术、Streaming SIMD 指令和 SSE2 指令集
• 400 或 533 MHz、源同步处理器系统总线
• 使用增强型英特尔 SpeedStep® 技术的高级电源管理

2.1.10 英特尔® 奔腾® 处理器至尊版 (2005)

英特尔奔腾处理器至尊版引入了双核技术。 该技术提供高级硬件多线程支持。 该处理器基于英特尔 NetBurst 微架构，支持 SSE、SSE2、SSE3、超线程技术和英特尔 64 位架构。
也可以看看：
• 第 2.2.2 节，“英特尔 NetBurst® 微架构”
• 第 2.2.3 节，“英特尔® 酷睿™ 微架构”
• 第 2.2.7 节，“SIMD 指令”
• 第 2.2.8 节，“英特尔® 超线程技术”
• 第 2.2.9 节，“多核技术”
• 第 2.2.10 节，“英特尔® 64 位架构”

2.1.11 英特尔® 酷睿™ 双核处理器和英特尔® 酷睿™ 单核处理器 (2006-2007)

Intel Core Duo 处理器提供高能效的双核性能以及可延长电池寿命的低功耗设计。 该系列和单核 Intel Core Solo 处理器提供了优于 Pentium M 处理器系列的微体系结构增强功能。
其增强的微架构包括：
• Intel® Smart Cache 允许在两个处理器内核之间高效共享数据
• 改进的解码和 SIMD 执行
• Intel® Dynamic Power Coordination 和 Enhanced Intel® Deeper Sleep 以降低功耗
• Intel® Advanced Thermal Manager，具有数字热传感器接口
• 支持功率优化的 667 MHz 总线
双核 Intel Xeon 处理器 LV 基于与 Intel Core Duo 处理器相同的微架构，并支持 IA-32 架构。

2.1.12 英特尔® 至强® 处理器 5100、5300 系列和英特尔® 酷睿™2 处理器家族 (2006)

Intel Xeon 处理器 3000、3200、5100、5300 和 7300 系列、Intel Pentium Dual-Core、Intel Core 2 Extreme、Intel Core 2 Quad 处理器和 Intel Core 2 Duo 处理器家族支持 Intel 64 架构； 它们基于基于 65 纳米工艺技术构建的高性能、高能效英特尔® 酷睿微架构。 英特尔酷睿微架构包括以下创新特性：
• Intel® Wide Dynamic Execution 可提高性能和执行吞吐量
• Intel® Intelligent Power Capability 可降低功耗
• Intel® Advanced Smart Cache 允许在两个处理器内核之间高效共享数据
• 英特尔® 智能内存访问可增加数据带宽并隐藏内存访问延迟
• Intel® Advanced Digital Media Boost 使用多代 Streaming SIMD 扩展提高应用程序性能 Intel Xeon 处理器 5300 系列、Intel Core 2 Extreme 处理器 QX6800 系列和 Intel Core 2 Quad 处理器支持 Intel 四核技术。

2.1.13 英特尔® 至强® 处理器 5200、5400、7400 系列和英特尔® 酷睿™2 处理器家族 (2007)

英特尔至强处理器5200、5400、7400系列、英特尔酷睿2四核处理器Q9000系列、英特尔酷睿2双核处理器E8000系列支持英特尔64位架构； 它们基于使用 45 纳米工艺技术的增强型英特尔® 酷睿微架构。 增强型英特尔酷睿微架构提供以下改进功能：
• 基数 16 分频器、更快的操作系统原语进一步提高了英特尔® 宽动态执行的性能。
• 改进了英特尔® 高级智能高速缓存，二级高速缓存增加了 50%，路组关联性增加了 50%。
• 128 位洗牌引擎显着提高了英特尔® 高级数字媒体加速和 SSE4 的性能。
英特尔至强处理器 5400 系列和英特尔酷睿 2 四核处理器 Q9000 系列支持英特尔四核技术。 Intel Xeon 处理器 7400 系列提供多达六个处理器内核和一个高达 16 MB 的 L3 缓存。

2.1.14 英特尔凌动® 处理器家族 (2008)

第一代英特尔凌动® 处理器基于 45 纳米工艺技术构建。 它们基于一种新的微架构，即英特尔凌动® 微架构，该架构针对超低功耗设备进行了优化。 英特尔凌动® 微架构具有两个有序执行管道，可最大限度地降低功耗、延长电池寿命并实现超小尺寸。 最初的英特尔凌动处理器家族和包括英特尔凌动处理器 D2000、N2000、E2000、Z2000、C1000 系列在内的后续几代产品提供以下功能：
• 增强型英特尔® SpeedStep® 技术。
• 英特尔® 超线程技术。
• 具有动态高速缓存大小调整的深度断电技术。
• 支持指令集扩展，包括 Supplemental Streaming SIMD Extensions 3 (SSSE3)。
• 支持英特尔® 虚拟化技术。
• 支持Intel® 64 架构（不包括Intel Atom 处理器Z5xx 系列）。

2.1.15 基于 Silvermont 微架构的英特尔凌动® 处理器家族 (2013)

英特尔凌动处理器 C2xxx、E3xxx、S1xxx 系列基于 Silvermont 微架构。 基于 Silvermont 微架构的处理器支持指令集扩展，包括 SSE4.2、AESNI 和 PCLMULQDQ。

2.1.16 英特尔® 酷睿™ i7 处理器家族 (2008)

英特尔酷睿i7处理器900系列支持英特尔64位架构； 它们基于使用 45 纳米工艺技术的 Nehalem 微架构。 英特尔酷睿 i7 处理器和英特尔至强处理器 5500 系列包括以下特性：
• Intel® Turbo Boost 技术将散热空间转化为更高的性能。
• Intel® HyperThreading 技术结合Quadcore 提供四核和八线程。
• 专用电源控制单元可降低活动和闲置功耗。
• 处理器上的集成内存控制器支持三通道DDR3 内存。
• 8 MB 包含英特尔® 智能高速缓存。
• Intel® QuickPath 互连 (QPI) 提供到芯片组的点对点链接。
• 支持SSE4.2 和SSE4.1 指令集。
• 第二代英特尔虚拟化技术

2.1.17 英特尔® 至强® 处理器 7500 系列 (2010)
英特尔至强处理器 7500 和 6500 系列基于使用 45 纳米工艺技术的 Nehalem 微架构。 它们支持第 2.1.16 节中描述的相同功能，以及以下功能：
• 每个物理处理器包最多八个内核。
• 高达 24 MB 的英特尔® 智能高速缓存。
• 提供带有英特尔® 7500 可扩展内存缓冲器的英特尔® 可扩展内存互连（英特尔® SMI）通道以连接到系统内存。
• 支持软件可恢复机器检查架构的高级RAS。

2.1.18 2010 英特尔® 酷睿™ 处理器家族 (2010)

2010 英特尔酷睿处理器系列包括英特尔酷睿 i7、i5 和 i3 处理器。 它们基于使用 32 纳米工艺技术的 Westmere 微架构。 这些功能包括：
• 使用英特尔超线程技术和英特尔睿频加速技术提供智能性能。
• 增强型英特尔智能高速缓存和集成内存控制器。
• 智能电源门控。
• 重新分区的平台具有45 纳米集成图形的片上集成。
• 指令集支持范围高达AESNI、PCLMULQDQ、SSE4.2 和SSE4.1。

2.1.19 英特尔® 至强® 处理器 5600 系列 (2010)

英特尔至强处理器 5600 系列基于采用 32 纳米工艺技术的 Westmere 微架构。
它们支持第 2.1.16 节中描述的相同功能，以及以下功能：
• 每个物理处理器包最多六个内核。
• 高达 12 MB 的增强型英特尔® 智能高速缓存。
• 支持AESNI、PCLMULQDQ、SSE4.2 和SSE4.1 指令集。
• 跨处理器和I/O 的灵活英特尔虚拟化技术。

2.1.20 第二代英特尔® 酷睿™ 处理器家族 (2011)

第二代英特尔酷睿处理器系列包括基于 Sandy Bridge 微架构的英特尔酷睿 i7、i5 和 i3 处理器。 它们采用 32 nm 工艺技术构建，具有以下特性：
• 适用于英特尔酷睿 i5 和 i7 处理器的英特尔睿频加速技术
• 英特尔超线程技术。
• 增强型英特尔智能高速缓存和集成内存控制器。
• 处理器图形和内置视觉功能，如 Intel® Quick Sync Video、Intel® InsiderTM 等。
• 指令集支持范围高达AVX、AESNI、PCLMULQDQ、SSE4.2 和SSE4.1。
英特尔至强处理器 E3-1200 产品系列也基于 Sandy Bridge 微架构。
英特尔至强处理器 E5-2400/1400 产品系列基于 Sandy Bridge-EP 微架构。
英特尔至强处理器 E5-4600/2600/1600 产品系列基于 Sandy Bridge-EP 微架构，并提供对多插槽的支持。

2.1.21 第三代英特尔® 酷睿™ 处理器家族 (2012)

第三代英特尔酷睿处理器系列包括基于 Ivy Bridge 微架构的英特尔酷睿 i7、i5 和 i3 处理器。 英特尔至强处理器 E7-8800/4800/2800 v2 产品家族和英特尔至强处理器 E3-1200 v2 产品家族也基于 Ivy Bridge 微架构。
英特尔至强处理器 E5-2400/1400 v2 产品系列基于 Ivy Bridge-EP 微架构。
Intel Xeon 处理器 E5-4600/2600/1600 v2 产品系列基于 Ivy Bridge-EP 微架构并提供对多插槽的支持

2.1.22 第四代英特尔® 酷睿™ 处理器家族 (2013)
第四代英特尔酷睿处理器系列包括基于 Haswell 微架构的英特尔酷睿 i7、i5 和 i3 处理器。 英特尔至强处理器 E3-1200 v3 产品家族也基于 Haswell 微架构。
2.2 更多具体进展
以下部分提供了有关主要创新的更多信息。
2.2.1 P6 家族微架构
Pentium Pro 处理器引入了一种新的微体系结构，通常称为 P6 处理器微体系结构。 P6 处理器微架构后来通过称为高级传输缓存的片上二级缓存得到增强。
微架构是一种三路超标量流水线架构。 三路超标量意味着通过使用并行处理技术，处理器平均每个时钟周期能够解码、分派和完成（退出）三个指令。 为处理这种级别的指令吞吐量，P6 处理器系列使用支持无序指令执行的解耦 12 级超级流水线。
图 2-1 显示了具有高级传输缓存增强功能的 P6 处理器微体系结构流水线的概念视图。

![image-20230310193447296](C:\Users\mark.wu\AppData\Roaming\Typora\typora-user-images\image-20230310193447296.png)

为确保为指令执行流水线提供稳定的指令和数据，P6 处理器微架构包含两个缓存级别。 一级缓存提供一个 8 KB 的指令缓存和一个 8 KB 的数据缓存，两者都与流水线紧密耦合。 二级缓存提供 256-KByte、512-KByte 或 1-MByte 静态 RAM，通过全时钟速度 64 位缓存总线耦合到核心处理器。
P6 处理器微体系结构的核心是称为动态执行的乱序执行机制。 动态执行包含三个数据处理概念：

深度分支预测允许处理器对分支之外的指令进行解码，以保持指令流水线充满。 P6 处理器系列采用高度优化的分支预测算法来预测指令的方向。
• 动态数据流分析需要对通过处理器的数据流进行实时分析，以确定相关性并检测乱序指令执行的机会。 乱序执行内核可以监控许多指令并以最优化处理器多个执行单元使用的顺序执行这些指令，同时保持数据完整性。
• 推测执行是指处理器能够执行位于尚未解决的条件分支之外的指令，并最终按照原始指令流的顺序提交结果。 为了使推测执行成为可能，P6 处理器微体系结构将指令的分派和执行与结果的提交分离开来。 处理器的乱序执行核心使用数据流分析来执行指令池中的所有可用指令，并将结果存储在临时寄存器中。 退役单元然后线性搜索指令池以查找已完成的指令，这些指令不再与其他指令或未解决的分支预测具有数据依赖性。 当找到完整的指令时，退役单元按照它们最初发出的顺序将这些指令的结果提交到内存和/或 IA-32 寄存器（处理器的八个通用寄存器和八个 x87 FPU 数据寄存器）并退役 来自指令池的指令。

2.2.2 英特尔 NetBurst® 微架构
Intel NetBurst 微架构提供：
• 快速执行引擎
— 算术逻辑单元 (ALU) 以处理器频率的两倍运行
— 基本整数运算可以在 1/2 处理器时钟节拍内分派
• 超流水线技术
— 为台式 PC 和服务器提供行业领先的时钟速率的深度流水线
— 频率余量和可扩展性，以继续引领未来
• 高级动态执行
— 深度的、无序的、推测性的执行引擎
• 多达 126 条指令在执行中
• 管道中多达 48 次加载和 24 次存储1
— 增强的分支预测能力
• 减少与更深管道相关的错误预测惩罚
• 先进的分支预测算法
• 4K 条目分支目标数组
• 新缓存子系统
— 一级缓存
• Advanced Execution Trace Cache 存储解码指令
• 执行跟踪缓存消除了主执行循环中的解码器延迟
• Execution Trace Cache 将程序执行流程的路径整合到一行中
• 低延迟数据缓存
— 二级缓存
• 全速、统一的 8 路 2 级片上高级传输缓存
• 带宽和性能随着处理器频率的增加而增加

英特尔 NetBurst 微体系结构系统总线的高性能、四泵总线接口
— 支持四泵、可扩展总线时钟以实现高达 4 倍的有效速度
— 每秒能够提供高达 8.5 GBytes 的带宽
• 支持并行性的超标量问题
• 通过重命名扩展硬件寄存器以避免寄存器名称空间限制
• 64 字节缓存行大小（每个扇区最多传输两行数据）
图 2-2 是 Intel NetBurst 微体系结构的概览。 该微架构流水线由三部分组成：(1) 前端流水线，(2) 乱序执行核心，以及 (3) 退役单元。

![image-20230310194830464](C:\Users\mark.wu\AppData\Roaming\Typora\typora-user-images\image-20230310194830464.png)

2.2.2.1 前端流水线
前端按程序顺序向乱序执行核心提供指令。 它执行许多功能：
• 预取可能执行的指令
• 获取尚未预取的指令
• 将指令解码为微操作
• 为复杂指令和专用代码生成微代码
• 提供来自执行跟踪缓存的解码指令
• 使用高度先进的算法预测分支
流水线旨在解决高速流水线微处理器中的常见问题。 其中两个问题是导致延误的主要原因：
• 解码从目标获取的指令的时间

由于高速缓存行中间的分支或分支目标而浪费解码带宽
管道跟踪缓存的操作解决了这些问题。 指令不断地被翻译引擎（提取/解码逻辑的一部分）提取和解码，并被构建到称为跟踪的微操作序列中。 在任何时候，多个跟踪（代表预取分支）都存储在跟踪缓存中。 在跟踪缓存中搜索活动分支之后的指令。 如果该指令也作为预取分支中的第一条指令出现，则从存储器层次结构中提取和解码指令将停止，并且预取分支将成为新的指令源（见图 2-2）。
跟踪缓存和翻译引擎具有协作的分支预测硬件。 使用分支目标缓冲区 (BTB) 根据其线性地址预测分支目标并尽快获取。

2.2.2.2 乱序执行核心

乱序执行核心乱序执行指令的能力是实现并行性的关键因素。
此功能使处理器能够重新排序指令，以便如果一个微操作被延迟，其他微操作可能会绕过它进行。 处理器使用多个缓冲区来平滑微操作流。
核心旨在促进并行执行。 它每个周期最多可以分派六个微操作（这超过了跟踪缓存和退休微操作带宽）。 大多数流水线可以在每个周期开始执行一个新的微操作，因此可以为每个流水线一次运行多条指令。 许多算术逻辑单元 (ALU) 指令可以从每个周期两条开始； 许多浮点指令可以每两个周期启动一次。
2.2.2.3 退休单位
退役单元从乱序执行核心接收微操作的执行结果并处理结果，以便架构状态根据原始程序顺序更新。
当一个微操作完成并写入它的结果时，它就退休了。 每个周期最多可以退出三个微操作。 Reorder Buffer (ROB) 是处理器中的一个单元，它缓冲完成的微操作，按顺序更新架构状态，并管理异常的排序。 引退部分还跟踪分支并将更新的分支目标信息发送到BTB。 然后 BTB 清除不再需要的预取跟踪。

2.2.3 Intel® Core™ 微架构
英特尔酷睿微架构引入了以下功能，可为单线程和多线程工作负载提供高性能和节能性能：
• Intel® Wide Dynamic Execution 使每个处理器内核能够在高带宽下获取、分派和执行，以支持每个周期最多退出 4 条指令。
— 十四级高效流水线
— 三个算术逻辑单元
— 四个解码器，每个周期最多可解码 5 条指令
— 宏观融合和微观融合提高前端吞吐量
— 每个周期最多发送 6 个微操作的峰值发布率
— 每个周期最多 4 个微操作的峰值退休带宽
— 高级分支预测
— 堆栈指针跟踪器以提高执行函数/过程入口和出口的效率
• Intel® Advanced Smart Cache 提供从二级缓存到内核的更高带宽，以及单线程和多线程应用程序的最佳性能和灵活性。
— 高达 4 MB 的大型二级缓存和 16 路关联性
— 针对多核和单线程执行环境进行了优化
— 256 位内部数据路径，提高从 L2 到一级数据缓存的带宽

英特尔® 智能内存访问根据数据访问模式从内存中预取数据，并减少乱序执行的缓存未命中风险。
— 硬件预取器可减少二级缓存未命中的有效延迟
— 硬件预取器可减少一级数据缓存未命中的有效延迟
— 内存消歧提高推测执行执行引擎的效率
• Intel® Advanced Digital Media Boost 通过单周期吞吐量和浮点运算改进了大多数 128 位 SIMD 指令。
— 大多数 128 位 SIMD 指令的单周期吞吐量
— 每个周期最多八个浮点运算
— 可用于调度 SIMD 指令执行的三个问题端口
Intel Core 2 Extreme、Intel Core 2 Duo 处理器和Intel Xeon 处理器5100 系列基于Intel Core 微架构实现了两个处理器内核，每个内核中子系统的功能如图2-3 所示。

![image-20230310195440535](C:\Users\mark.wu\AppData\Roaming\Typora\typora-user-images\image-20230310195440535.png)

2.2.3.1 前端
Intel Core 微架构的前端提供了多项增强功能来支持 Intel Wide Dynamic Execution 引擎：
• 指令获取单元将指令预取到指令队列中，以维持对解码单元的稳定指令供应。
• 四宽解码单元可以解码每周期4 条指令或使用Macrofusion 时每周期解码5 条指令。
• Macrofusion 将两条指令的公共序列融合为一条解码指令（微操作）以提高解码吞吐量。
• Microfusion 将两个微操作的公共序列融合为一个微操作，以提高退休吞吐量。

• 指令队列提供短循环的缓存以提高效率。
• 堆栈指针跟踪器提高了执行过程/函数入口和出口的效率。
• 分支预测单元采用专用硬件来处理不同类型的分支以改进分支预测。
• 高级分支预测算法指导指令获取单元获取可能在架构代码路径中的指令以进行解码。
2.2.3.2 执行核心
英特尔酷睿微架构的执行核心是超标量的，可以乱序处理指令，以提高每周期执行指令 (IPC) 的整体速率。 执行核心采用以下特性来提高执行吞吐量和效率：
• 每个周期最多可以分派六个微操作来执行
• 每个周期最多可退出 4 条指令
• 三个完整的算术逻辑单元
• SIMD 指令可以通过三个发布端口发送
• 大多数 SIMD 指令具有 1 个周期的吞吐量（包括 128 位 SIMD 指令）
• 每个周期最多八个浮点运算
• 许多长延迟计算操作在硬件中流水线化以提高整体吞吐量
• 使用 Intel Smart Memory Access 减少数据访问延迟

3.4 基本程序执行寄存器
IA-32 体系结构提供了 16 个基本程序执行寄存器，用于一般系统和应用程序编程（见图 3-4）。 这些寄存器可以按如下方式分组：
.通用寄存器。 这八个寄存器可用于存储操作数和指针。
• 段寄存器。 这些寄存器最多包含六个段选择器。
• EFLAGS（程序状态和控制）寄存器。 EFLAGS 寄存器报告正在执行的程序的状态，并允许对处理器进行有限的（应用程序级别）控制。
• EIP（指令指针）寄存器。 EIP 寄存器包含一个指向下一条要执行的指令的 32 位指针。

3.4.1 通用寄存器
32 位通用寄存器 EAX、EBX、ECX、EDX、ESI、EDI、EBP 和 ESP 用于保存以下项目：
• 逻辑和算术运算的操作数
• 地址计算的操作数
• 内存指针
尽管所有这些寄存器都可用于操作数、结果和指针的一般存储，但在引用 ESP 寄存器时应谨慎使用。 ESP 寄存器保存堆栈指针，并且作为一般规则不应用于其他目的。
许多指令分配特定的寄存器来保存操作数。 例如，字符串指令使用 ECX、ESI 和 EDI 寄存器的内容作为操作数。 当使用分段内存模型时，一些指令假定某些寄存器中的指针是相对于特定段的。 例如，某些指令假定 EBX 寄存器中的指针指向 DS 段中的内存位置。

![image-20230310195942469](C:\Users\mark.wu\AppData\Roaming\Typora\typora-user-images\image-20230310195942469.png)

本卷第 5 章“指令集摘要”中描述了指令对通用寄存器的特殊用途。 另请参阅：英特尔® 64 和 IA-32 架构软件开发人员手册第 3 章、第 4 章、第 5 章和第 6 章，第 2A、2B、2C 和 2D 卷。 以下是特殊用途的总结：
• EAX — 操作数和结果数据的累加器
• EBX — 指向 DS 段中数据的指针
• ECX — 字符串和循环操作的计数器
• EDX — I/O 指针
• ESI——指向DS 寄存器指向的段中数据的指针； 字符串操作的源指针
• EDI — 指向 ES 寄存器指向的段中的数据（或目标）的指针； 字符串操作的目标指针
• ESP — 堆栈指针（在 SS 段中）
• EBP — 指向堆栈上数据的指针（在 SS 段中）
如图 3-5 所示，通用寄存器的低 16 位直接映射到 8086 和 Intel 286 处理器中的寄存器组，可以用名称 AX、BX、CX、DX、BP、SI 引用 、DI 和 SP。 EAX、EBX、ECX 和 EDX 寄存器的低两个字节中的每一个都可以通过名称 AH、BH、CH 和 DH（高字节）和 AL、BL、CL 和 DL（低字节）来引用。

![image-20230310200118761](C:\Users\mark.wu\AppData\Roaming\Typora\typora-user-images\image-20230310200118761.png)

3.4.1.1 64 位模式下的通用寄存器
在 64 位模式下，有 16 个通用寄存器，默认操作数大小为 32 位。 但是，通用寄存器能够使用 32 位或 64 位操作数。 如果指定了 32 位操作数大小：EAX、EBX、ECX、EDX、EDI、ESI、EBP、ESP、R8D - R15D 可用。 如果指定了 64 位操作数大小：RAX、RBX、RCX、RDX、RDI、RSI、RBP、RSP、R8-R15 可用。 R8D-R15D/R8-R15 代表八个新的通用寄存器。
所有这些寄存器都可以在字节、字、双字和四字级别进行访问。 REX 前缀用于生成 64 位操作数大小或引用寄存器 R8-R15。
仅在 64 位模式（R8-R15 和 XMM8-XMM15）中可用的寄存器在从 64 位模式到兼容模式然后再回到 64 位模式的转换中被保留。 但是，在从 64 位模式通过兼容模式转换到传统或实模式，然后通过兼容模式返回到 64 位模式后，R8-R15 和 XMM8-XMM15 的值未定义

![image-20230310200230937](C:\Users\mark.wu\AppData\Roaming\Typora\typora-user-images\image-20230310200230937.png)

在 64 位模式下，访问字节寄存器有限制。 一条指令不能同时引用旧的高字节（例如：AH、BH、CH、DH）和其中一个新字节寄存器（例如：RAX 寄存器的低字节）。 但是，指令可能同时引用旧的低字节（例如：AL、BL、CL 或 DL）和新字节寄存器（例如：R8 寄存器的低字节，或 RBP）。 该体系结构通过将高字节引用（AH、BH、CH、DH）更改为使用 REX 前缀的指令的低字节引（BPL、SPL、DIL、SIL：RBP、RSP、RDI 和 RSI 的低 8 位）用来强制执行此限制。
在 64 位模式下，操作数大小决定了目标通用寄存器中的有效位数：
• 64 位操作数在目标通用寄存器中生成64 位结果。
• 32 位操作数生成一个 32 位结果，在目标通用寄存器中零扩展为 64 位结果。
• 8 位和16 位操作数生成8 位或16 位结果。 目标通用寄存器的高 56 位或 48 位（分别）不会被操作修改。 如果 8 位或 16 位运算的结果用于 64 位地址计算，则显式将寄存器符号扩展为完整的 64 位。
由于 64 位通用寄存器的高 32 位在 32 位模式下未定义，因此从 64 位模式切换到 32 位模式时，不会保留任何通用寄存器的高 32 位（到保护模式或兼容模式）。 在 64 位到 32 位模式切换后，软件不得依赖这些位来维护值。

3.4.2 段寄存器

段寄存器（CS、DS、SS、ES、FS 和 GS）保存 16 位段选择器。 段选择器是一种特殊的指针，用于标识内存中的段。 要访问内存中的特定段，该段的段选择器必须存在于相应的段寄存器中。
在编写应用程序代码时，程序员通常会使用汇编指令和符号来创建段选择器。 汇编器和其他工具然后创建与这些指令和符号关联的实际段选择器值。 如果编写系统代码，程序员可能需要直接创建段选择器。 请参阅英特尔® 64 位和 IA-32 架构软件开发人员手册第 3A 卷中的第 3 章“保护模式内存管理”。
段寄存器的使用方式取决于操作系统或执行程序使用的内存管理模型的类型。 当使用平面（未分段）内存模型时，段寄存器加载有指向重叠段的段选择器，每个段都从线性地址空间的地址 0 开始（见图 3-6）。 这些重叠的段然后构成程序的线性地址空间。 通常，会定义两个重叠段：一个用于代码，另一个用于数据和堆栈。 CS段寄存器指向代码段，所有其他段寄存器指向数据和堆栈段。
使用分段内存模型时，每个段寄存器通常加载不同的段选择器，以便每个段寄存器指向线性地址空间中的不同段（见图 3-7）。 因此，在任何时候，一个程序最多可以访问线性地址空间中的六个段。 要访问一个段寄存器未指向的段，程序必须首先将要访问的段的段选择器加载到段寄存器中。

![image-20230310201247117](C:\Users\mark.wu\AppData\Roaming\Typora\typora-user-images\image-20230310201247117.png)

每个段寄存器都与三种存储类型之一相关联：代码、数据或堆栈。 例如，CS 寄存器包含代码段的段选择器，其中存储正在执行的指令。 处理器使用由 CS 寄存器中的段选择符和 EIP 寄存器的内容组成的逻辑地址从代码段中获取指令。 EIP 寄存器包含下一条要执行的指令在代码段内的偏移量。 应用程序不能显式加载 CS 寄存器。 相反，它由改变程序控制的指令或内部处理器操作（例如过程调用、中断处理或任务切换）隐式加载。
DS、ES、FS 和 GS 寄存器指向四个数据段。 四个数据段的可用性允许对不同类型的数据结构进行高效和安全的访问。 例如，可以创建四个单独的数据段：一个用于当前模块的数据结构，另一个用于从更高级别模块导出的数据，第三个用于动态创建的数据结构，第四个用于与另一个程序共享的数据。 要访问其他数据段，应用程序必须根据需要将这些段的段选择器加载到 DS、ES、FS 和 GS 寄存器中。
SS 寄存器包含堆栈段的段选择器，其中存储当前正在执行的程序、任务或处理程序的过程堆栈。 所有堆栈操作都使用 SS 寄存器来查找堆栈段。 与 CS 寄存器不同，SS 寄存器可以显式加载，允许应用程序建立多个堆栈并在它们之间切换。
有关段寄存器如何在实地址模式下使用的概述，请参见第 3.3 节“内存组织”。
四个段寄存器 CS、DS、SS 和 ES 与 Intel 8086 和 Intel 286 处理器中的段寄存器相同，而 FS 和 GS 寄存器是在 Intel386™ 系列处理器中引入到 IA-32 架构中的。

3.4.2.1 64 位模式下的段寄存器
在 64 位模式下：CS、DS、ES、SS 被视为每个段基数都为 0，而不管关联的段描述符基数的值如何。 这为代码、数据和堆栈创建了一个平面地址空间。 FS 和 GS 是例外。
这两个段寄存器都可以用作线性地址计算中的附加基址寄存器（在本地数据和某些操作系统数据结构的寻址中）。
即使分段通常被禁用，段寄存器加载也可能导致处理器执行段访问辅助。 在这些活动期间，启用的处理器仍将对加载的值执行大部分旧版检查（即使这些检查不适用于 64 位模式）。 需要进行此类检查，因为在兼容模式下运行的应用程序可能会使用以 64 位模式加载的段寄存器。
CS、DS、ES、SS、FS 和 GS 的限制检查在 64 位模式下被禁用。

3.4.3 EFLAGS 寄存器
32位的EFLAGS寄存器包含一组状态标志、一个控制标志和一组系统标志。 图 3-8 定义了该寄存器中的标志。 处理器初始化后（通过断言 RESET 引脚或 INIT 引脚），EFLAGS 寄存器的状态为 00000002H。 该寄存器的位 1、3、5、15 和 22 至 31 保留。 软件不应使用或依赖任何这些位的状态。
EFLAGS 寄存器中的一些标志可以使用专用指令（在以下部分中描述）直接修改。 没有允许直接检查或修改整个寄存器的指令。
以下指令可用于将标志组移入和移出过程堆栈或 EAX 寄存器：
LAHF、SAHF、PUSHF、PUSHFD、POPF 和 POPFD。 将 EFLAGS 寄存器的内容传输到过程堆栈或 EAX 寄存器后，可以使用处理器的位操作指令（BT、BTS、BTR 和 BTC）检查和修改标志。
挂起任务时（使用处理器的多任务功能），处理器会自动将 EFLAGS 寄存器的状态保存在任务状态段 (TSS) 中，用于挂起的任务。 将自身绑定到新任务时，处理器会将来自新任务的 TSS 的数据加载到 EFLAGS 寄存器。
当调用中断或异常处理程序时，处理器会自动将 EFLAGS 寄存器的状态保存在过程堆栈中。 当使用任务切换处理中断或异常时，EFLAGS 寄存器的状态将保存在 TSS 中，用于挂起的任务。

![image-20230310201942271](C:\Users\mark.wu\AppData\Roaming\Typora\typora-user-images\image-20230310201942271.png)

随着 IA-32 架构的发展，标志已添加到 EFLAGS 寄存器中，但现有标志的功能和位置从一个 IA-32 处理器系列到下一个系列都保持不变。 因此，为一个 IA-32 处理器系列访问或修改这些标志的代码在以后的处理器系列上运行时按预期工作。

3.4.3.1 状态标志
EFLAGS 寄存器的状态标志（位 0、2、4、6、7 和 11）指示算术指令的结果，例如 ADD、SUB、MUL 和 DIV 指令。 状态标志函数是：
CF（位 0）进位标志——如果算术运算从结果的最高位产生进位或借位，则置位； 否则清除。 此标志指示无符号整数算术的溢出条件。 它也用于多精度算术。
PF（第 2 位）奇偶校验标志 - 如果结果的最低有效字节包含偶数个 1 位，则设置； 否则清除。
AF（第 4 位）辅助进位标志 - 如果算术运算从结果的第 3 位产生进位或借位，则置位； 否则清除。 此标志用于二进制编码的十进制 (BCD) 算术。
ZF（位 6）零标志——如果结果为零则置位； 否则清除。
SF（第 7 位）符号标志 - 设置为等于结果的最高有效位，这是有符号整数的符号位。 （0 表示正值，1 表示负值。）
OF（第 11 位）溢出标志 - 如果整数结果是太大的正数或太小的负数（不包括符号位）以适应目标操作数； 否则清除。 此标志指示有符号整数（二进制补码）算术的溢出条件。
在这些状态标志中，只有 CF 标志可以使用 STC、CLC 和 CMC 指令直接修改。 位指令（BT、BTS、BTR 和 BTC）也将指定位复制到 CF 标志中。

状态标志允许单个算术运算产生三种不同数据类型的结果：无符号整数、有符号整数和 BCD 整数。 如果算术运算的结果被视为无符号整数，则 CF 标志指示超出范围的条件（进位或借位）； 如果被视为有符号整数（二进制补码），则 OF 标志表示进位或借位； 如果将其视为 BCD 数字，则 AF 标志表示进位或借位。 SF 标志表示有符号整数的符号。 ZF 标志指示有符号或无符号整数零。
对整数执行多精度算术时，CF 标志与进位加法 (ADC) 和借位减法 (SBB) 指令结合使用，以将进位或借位从一个计算传播到下一个计算。
条件指令 Jcc（在条件代码 cc 上跳转）、SETcc（在条件代码 cc 上设置字节）、LOOPcc 和 CMOVcc（条件移动）使用一个或多个状态标志作为条件代码并测试它们的分支、设置字节或 结束循环条件。
3.4.3.2 DF 标志
方向标志（DF，位于 EFLAGS 寄存器的第 10 位）控制字符串指令（MOVS、CMPS、SCAS、LODS 和 STOS）。 设置 DF 标志会导致字符串指令自动递减（将字符串从高地址处理到低地址）。 清除 DF 标志会导致字符串指令自动递增（从低地址到高地址处理字符串）。
STD 和 CLD 指令分别设置和清除 DF 标志。

3.4.3.3 系统标志和 IOPL 字段
EFLAGS 寄存器中的系统标志和 IOPL 字段控制操作系统或执行操作。 它们不应被应用程序修改。 系统标志的作用如下：
TF（第 8 位）陷阱标志 - 设置为启用单步调试模式； 清除以禁用单步模式。
IF（第 9 位）中断启用标志 — 控制处理器对可屏蔽中断请求的响应。 设置响应可屏蔽中断； 清除以抑制可屏蔽中断。
IOPL（位 12 和 13）
I/O 权限级别字段——指示当前运行的程序或任务的 I/O 权限级别。 当前正在运行的程序或任务的当前特权级别（CPL）必须小于或等于 I/O 特权级别才能访问 I/O 地址空间。 只有在 CPL 为 0 时，POPF 和 IRET 指令才能修改该字段。
NT（位 14）嵌套任务标志 — 控制中断和调用任务的链接。 当当前任务链接到先前执行的任务时设置； 当前任务未链接到另一个任务时清除。
RF（位 16）恢复标志 — 控制处理器对调试异常的响应。
VM（第 17 位）虚拟 8086 模式标志 — 设置为启用虚拟 8086 模式； 清除返回受保护
没有虚拟 8086 模式语义的模式。
AC（第 18 位）对齐检查（或访问控制）标志 — 如果 CR0 寄存器中设置了 AM 位，则当且仅当此标志为 1 时，才会启用用户模式数据访问的对齐检查。
如果在 CR4 寄存器中设置了 SMAP 位，则当且仅当该位为 1 时，才允许对用户模式页面进行显式管理模式数据访问。请参阅 Intel64 和 IA-32 架构中的第 4.6 节“访问权限” 软件开发人员手册，第 3A 卷。
VIF（位 19）虚拟中断标志 — IF 标志的虚拟映像。 与 VIP 标志一起使用。
（要使用此标志和 VIP 标志，通过在控制寄存器 CR4 中设置 VME 标志来启用虚拟模式扩展。）
VIP（位 20）虚拟中断挂起标志 — 设置为指示中断挂起； 当没有中断挂起时清除。 （软件设置和清除此标志；处理器仅读取它。）与 VIF 标志一起使用。
ID（位 21）标识标志 — 程序设置或清除此标志的能力表示支持 CPUID 指令。
有关这些标志的详细说明：请参阅英特尔® 64 位和 IA-32 架构软件开发人员手册第 3A 卷中的第 3 章“保护模式内存管理”。
3.4.3.4 64 位模式下的 RFLAGS 寄存器
在64位模式下，EFLAGS扩展为64位，称为RFLAGS。 RFLAGS 寄存器的高 32 位保留。 RFLAGS 的低 32 位与 EFLAGS 相同。



3.7 操作数寻址
IA-32 机器指令作用于零个或多个操作数。 一些操作数是显式指定的，而另一些是隐式的。 源操作数的数据可以位于：
• 指令本身（立即操作数）
• 一个寄存器
• 一个内存位置
• 一个输入/输出端口
当指令将数据返回到目标操作数时，它可以返回到：
• 一个寄存器
• 一个内存位置
• 一个输入/输出端口
3.7.1 立即数
一些指令使用在指令本身中编码的数据作为源操作数。 这些操作数称为立即操作数（或简称为立即数）。 例如，下面的 ADD 指令将立即数 14 添加到 EAX 寄存器的内容中：

ADD EAX，14
所有算术指令（DIV 和 IDIV 指令除外）都允许源操作数为立即值。 立即操作数允许的最大值因指令而异，但绝不能大于无符号双字整数 (2的32次方) 的最大值。

3.7.2 寄存器操作数
源操作数和目标操作数可以是以下任何寄存器，具体取决于正在执行的指令：
• 32 位通用寄存器（EAX、EBX、ECX、EDX、ESI、EDI、ESP 或 EBP）
• 16 位通用寄存器（AX、BX、CX、DX、SI、DI、SP 或 BP）
• 8 位通用寄存器（AH、BH、CH、DH、AL、BL、CL 或 DL）
• 段寄存器（CS、DS、SS、ES、FS 和 GS）
• EFLAGS 寄存器
• x87 FPU 寄存器（ST0 到 ST7、状态字、控制字、标记字、数据操作数指针和指令指针）
• MMX 寄存器（MM0 到 MM7）
• XMM 寄存器（XMM0 到 XMM7）和 MXCSR 寄存器
• 控制寄存器（CR0、CR2、CR3 和 CR4）和系统表指针寄存器（GDTR、LDTR、IDTR 和任务寄存器）
• 调试寄存器（DR0、DR1、DR2、DR3、DR6 和 DR7）
• MSR 寄存器
一些指令（例如 DIV 和 MUL 指令）使用包含在一对 32 位寄存器中的四字操作数。 寄存器对用冒号分隔它们表示。 例如，在寄存器对 EDX:EAX 中，EDX 包含四字操作数的高位，EAX 包含低位。
提供了若干指令（例如 PUSHFD 和 POPFD 指令）来加载和存储 EFLAGS 寄存器的内容，或者设置或清除该寄存器中的各个标志。 其他指令（例如 Jcc 指令）使用 EFLAGS 寄存器中状态标志的状态作为分支或其他决策制定操作的条件代码。
处理器包含一系列系统寄存器，用于控制内存管理、中断和异常处理、任务管理、处理器管理和调试活动。 其中一些系统寄存器可由应用程序、操作系统或执行程序通过一组系统指令访问。 当用系统指令访问系统寄存器时，寄存器通常是指令的隐含操作数。

3.7.2.1 64 位模式下的寄存器操作数
64 位模式下的寄存器操作数可以是以下任何一种：
• 64 位通用寄存器（RAX、RBX、RCX、RDX、RSI、RDI、RSP、RBP 或 R8-R15）
• 32 位通用寄存器（EAX、EBX、ECX、EDX、ESI、EDI、ESP、EBP 或 R8D-R15D）
• 16 位通用寄存器（AX、BX、CX、DX、SI、DI、SP、BP 或 R8W-R15W）
• 8 位通用寄存器：AL、BL、CL、DL、SIL、DIL、SPL、BPL 和 R8B-R15B 可使用 REX 前缀； AL、BL、CL、DL、AH、BH、CH、DH 无需使用 REX 前缀即可使用。
• 段寄存器（CS、DS、SS、ES、FS 和 GS）
• RFLAGS 寄存器
• x87 FPU 寄存器（ST0 到 ST7、状态字、控制字、标记字、数据操作数指针和指令指针）
• MMX 寄存器（MM0 到 MM7）
• XMM 寄存器（XMM0 到 XMM15）和 MXCSR 寄存器
• 控制寄存器（CR0、CR2、CR3、CR4 和 CR8）和系统表指针寄存器（GDTR、LDTR、IDTR 和任务寄存器）
• 调试寄存器（DR0、DR1、DR2、DR3、DR6 和 DR7）
• MSR 寄存器
• 代表 128 位操作数的 RDX:RAX 寄存器对

3.7.3 内存操作数
内存中的源操作数和目标操作数通过段选择器和偏移量引用（见图 3-9）。 段选择器指定包含操作数的段。 偏移指定操作数的线性或有效地址。 偏移量可以是 32 位（由符号 m16:32 表示）或 16 位（由符号 m16:16 表示）。

![image-20230310204431596](C:\Users\mark.wu\AppData\Roaming\Typora\typora-user-images\image-20230310204431596.png)

3.7.3.1 64 位模式下的内存操作数
在 64 位模式下，内存操作数可以由段选择器和偏移量引用。 偏移量可以是 16 位、32 位或 64 位（见图 3-10）。

![image-20230310204502017](C:\Users\mark.wu\AppData\Roaming\Typora\typora-user-images\image-20230310204502017.png)

3.7.4 指定段选择器
可以隐式或显式指定段选择器。 指定段选择器的最常见方法是将其加载到段寄存器中，然后允许处理器根据正在执行的操作类型隐式选择寄存器。 处理器根据表 3-5 中给出的规则自动选择段。

在内存中存储数据或从内存中加载数据时，可以覆盖 DS 段默认值以允许访问其他段。 在汇编程序中，段覆盖通常使用冒号“:”运算符处理。 例如，下面的 MOV 指令将一个值从寄存器 EAX 移到 ES 寄存器指向的段中。 段中的偏移量包含在 EBX 寄存器中：
MOV ES：[EBX]，EAX

![image-20230310204653346](C:\Users\mark.wu\AppData\Roaming\Typora\typora-user-images\image-20230310204653346.png)

在机器级别，段覆盖由段覆盖前缀指定，段覆盖前缀是位于指令开头的字节。 无法覆盖以下默认段选择：
• 取指令必须从代码段进行。
• 字符串指令中的目标字符串必须存储在ES 寄存器指向的数据段中。
• 推送和弹出操作必须始终引用SS 段。
一些指令需要明确指定段选择器。 在这些情况下，16 位段选择器可以位于内存位置或 16 位寄存器中。 例如，以下 MOV 指令将位于寄存器 BX 中的段选择器移动到段寄存器 DS 中：
MOV DS, BX
段选择器也可以明确指定为内存中 48 位远指针的一部分。 这里，内存中的第一个双字包含偏移量，下一个字包含段选择符。
3.7.4.1 64 位模式下的分段
在 IA-32e 模式下，分段的效果取决于处理器是运行在兼容模式还是 64 位模式。 在兼容模式下，分段功能与在传统 IA-32 模式下一样，使用上述 16 位或 32 位保护模式语义。
在 64 位模式下，分段通常（但不是完全）禁用，创建一个平坦的 64 位线性地址空间。 处理器将 CS、DS、ES、SS 的段基数视为零，创建一个等于有效地址的线性地址。 例外是 FS 和 GS 段，它们的段寄存器（保存段基址）可以用作某些线性地址计算中的附加基址寄存器。

3.7.5 指定偏移量
内存地址的偏移部分可以直接指定为静态值（称为位移）或通过由以下一个或多个组件组成的地址计算来指定：
• 位移——一个8 位、16 位或32 位的值。
• Base——通用寄存器中的值。
• 索引——通用寄存器中的值。
• 比例因子— 乘以索引值的2、4 或8 值。
添加这些组件所产生的偏移量称为有效地址。 这些组件中的每一个都可以具有正值或负值（2s 补码），比例因子除外。 图 3-11 显示了组合这些组件以在所选段中创建有效地址的所有可能方式。

![image-20230310204918469](C:\Users\mark.wu\AppData\Roaming\Typora\typora-user-images\image-20230310204918469.png)

使用通用寄存器作为基本或索引组件受到以下限制：
• ESP 寄存器不能用作变址寄存器。
• 当ESP 或EBP 寄存器用作基址时，SS 段是默认段。 在所有其他情况下，DS 段是默认段。
base、index 和 displacement 组件可以任意组合使用，并且这些组件中的任何一个都可以为 NULL。 只有在同时使用索引时才可以使用比例因子。 每种可能的组合对于程序员在高级语言和汇编语言中常用的数据结构都是有用的。
以下寻址模式建议使用地址组件的常见组合。
• 位移——位移单独表示对操作数的直接（未计算）偏移量。 因为位移是在指令中编码的，所以这种形式的地址有时被称为绝对地址或静态地址。 它通常用于访问静态分配的标量操作数。
• Base ⎯ 单独的一个base 表示一个对操作数的间接偏移量。 由于基址寄存器中的值可以改变，因此可以用于变量和数据结构的动态存储。
• Base + Displacement ⎯ 一个基址寄存器和一个位移可以一起用于两个不同的目的：
— 当元素大小不是 2、4 或 8 字节时作为数组的索引—位移分量将静态偏移编码到数组的开头。 基址寄存器保存计算结果以确定数组中特定元素的偏移量。
— 访问记录的字段：基址寄存器保存记录开头的地址，而位移是该字段的静态偏移量。
这种组合的一个重要特例是访问过程激活记录中的参数。 过程激活记录是在输入过程时创建的栈帧。 在这里，EBP 寄存器是基址寄存器的最佳选择，因为它会自动选择堆栈段。 这是此通用功能的紧凑编码。
• (Index * Scale) + Displacement ⎯ 当元素大小为 2、4 或 8 字节时，这种寻址模式提供了一种有效的方法来索引静态数组。 位移位于数组的开头，索引寄存器保存所需数组元素的下标，处理器通过应用比例因子自动将下标转换为索引。
• Base + Index + Displacement ⎯ 同时使用两个寄存器支持二维数组（位移包含数组开头的地址）或记录数组的多个实例之一
（位移是记录中字段的偏移量）。
• Base + (Index ∗ Scale) + Displacement ⎯ 当数组元素的大小为 2、4 或 8 字节时，将所有寻址组件一起使用允许高效索引二维数组。

3.7.5.1 在 64 位模式下指定偏移量
64 位模式下内存地址的偏移部分可以直接指定为静态值，也可以通过由以下一个或多个组件组成的地址计算来指定：
• 位移— 8 位、16 位或32 位值。
• Base — 64 位通用寄存器中的值。
• 索引——64 位通用寄存器中的值。
• 比例因子— 乘以索引值的2、4 或8 值。
在大多数情况下，可以在 16 个可用的通用寄存器之一中指定基数和索引值。 请参阅英特尔® 64 和 IA-32 架构软件开发人员手册第 2A 卷中的第 2 章“指令格式”。
以下地址组件的独特组合也可用。
• RIP + Displacement ⎯ 在64位模式下，RIP-relative addressing使用带符号的32位位移，通过对32位值进行符号扩展计算下一条指令的有效地址，并与RIP中的64位值相加 .
3.7.6 汇编器和编译器寻址模式
在机器代码级别，位移、基址寄存器、索引寄存器和比例因子的选定组合被编码在一条指令中。 所有汇编程序都允许程序员使用这些寻址组件的任何允许组合来寻址操作数。 高级语言编译器将根据程序员定义的语言结构选择这些组件的适当组合。
3.7.7 I/O 端口寻址
处理器支持包含多达 65,536 个 8 位 I/O 端口的 I/O 地址空间。 16 位和 32 位的端口也可以在 I/O 地址空间中定义。 I/O 端口可以使用立即操作数或 DX 寄存器中的值来寻址。 有关 I/O 端口寻址的更多信息，请参见第 19 章“输入/输出”。

本章介绍了为 Intel 64 和 IA-32 架构定义的数据类型。 本章末尾的一节介绍了 x87 FPU 和 Intel SSE、SSE2、SSE3、SSSE3、SSE4 和 AVX 扩展中使用的实数和浮点概念。
